/* eslint-disable */
 
/*!
 * @pixi-spine/loader-base - v3.0.7
 * Compiled Thu, 05 Aug 2021 12:00:16 UTC
 *
 * @pixi-spine/loader-base is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var loaders = require('@pixi/loaders');
var core = require('@pixi/core');
var base = require('@pixi-spine/base');
var constants = require('@pixi/constants');

function isJson(resource) {
    return resource.type === loaders.LoaderResource.TYPE.JSON;
}
function isBuffer(resource) {
    return resource.xhrType === loaders.LoaderResource.XHR_RESPONSE_TYPE.BUFFER;
}
loaders.LoaderResource.setExtensionXhrType('skel', loaders.LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
/**
 * @public
 */
var AbstractSpineParser = /** @class */ (function () {
    function AbstractSpineParser() {
    }
    AbstractSpineParser.prototype.genMiddleware = function () {
        var self = this;
        return {
            use: function (resource, next) {
                // skip if no data, its not json, or it isn't atlas data
                if (!resource.data) {
                    return next();
                }
                var isJsonSpineModel = isJson(resource) && resource.data.bones;
                var isBinarySpineModel = isBuffer(resource) && (resource.extension === 'skel' || resource.metadata
                    && resource.metadata.spineMetadata);
                if (!isJsonSpineModel && !isBinarySpineModel) {
                    return next();
                }
                var parser = null;
                var dataToParse = resource.data;
                if (isJsonSpineModel) {
                    parser = self.createJsonParser();
                }
                else {
                    parser = self.createBinaryParser();
                    if (resource.data instanceof ArrayBuffer) {
                        dataToParse = new Uint8Array(resource.data);
                    }
                }
                var metadata = (resource.metadata || {});
                var metadataSkeletonScale = metadata ? metadata.spineSkeletonScale : null;
                if (metadataSkeletonScale) {
                    parser.scale = metadataSkeletonScale;
                }
                var metadataAtlas = metadata.spineAtlas;
                if (metadataAtlas === false) {
                    return next();
                }
                if (metadataAtlas && metadataAtlas.pages) {
                    self.parseData(resource, parser, metadataAtlas, dataToParse);
                    return next();
                }
                var metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';
                /**
                 * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files
                 * that correspond to the spine file are in the same base URL and that the .json and .atlas files
                 * have the same name
                 */
                var atlasPath = resource.url;
                var queryStringPos = atlasPath.indexOf('?');
                if (queryStringPos > 0) {
                    //remove querystring
                    atlasPath = atlasPath.substr(0, queryStringPos);
                }
                atlasPath = atlasPath.substr(0, atlasPath.lastIndexOf('.')) + metadataAtlasSuffix;
                // use atlas path as a params. (no need to use same atlas file name with json file name)
                if (metadata.spineAtlasFile) {
                    atlasPath = metadata.spineAtlasFile;
                }
                //remove the baseUrl
                atlasPath = atlasPath.replace(this.baseUrl, '');
                var atlasOptions = {
                    crossOrigin: resource.crossOrigin,
                    xhrType: loaders.LoaderResource.XHR_RESPONSE_TYPE.TEXT,
                    metadata: metadata.spineMetadata || null,
                    parentResource: resource
                };
                var imageOptions = {
                    crossOrigin: resource.crossOrigin,
                    metadata: metadata.imageMetadata || null,
                    parentResource: resource
                };
                var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);
                //remove the baseUrl
                baseUrl = baseUrl.replace(this.baseUrl, '');
                var namePrefix = metadata.imageNamePrefix || (resource.name + '_atlas_page_');
                var adapter = metadata.images ? staticImageLoader(metadata.images)
                    : metadata.image ? staticImageLoader({ 'default': metadata.image })
                        : metadata.imageLoader ? metadata.imageLoader(this, namePrefix, baseUrl, imageOptions)
                            : imageLoaderAdapter(this, namePrefix, baseUrl, imageOptions);
                function createSkeletonWithRawAtlas(rawData) {
                    new base.TextureAtlas(rawData, adapter, function (spineAtlas) {
                        if (spineAtlas) {
                            self.parseData(resource, parser, spineAtlas, dataToParse);
                        }
                        next();
                    });
                }
                if (metadata.atlasRawData) {
                    createSkeletonWithRawAtlas(metadata.atlasRawData);
                }
                else {
                    this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource) {
                        if (!atlasResource.error) {
                            createSkeletonWithRawAtlas(atlasResource.data);
                        }
                        else {
                            next();
                        }
                    });
                }
            }
        };
    };
    return AbstractSpineParser;
}());
/**
 * @public
 */
function imageLoaderAdapter(loader, namePrefix, baseUrl, imageOptions) {
    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {
        baseUrl += '/';
    }
    return function (line, callback) {
        var name = namePrefix + line;
        var url = baseUrl + line;
        var cachedResource = loader.resources[name];
        if (cachedResource) {
            var done = function () {
                callback(cachedResource.texture.baseTexture);
            };
            if (cachedResource.texture) {
                done();
            }
            else {
                cachedResource.onAfterMiddleware.add(done);
            }
        }
        else {
            loader.add(name, url, imageOptions, function (resource) {
                if (!resource.error) {
                    if (line.indexOf('-pma.') >= 0) {
                        resource.texture.baseTexture.alphaMode = constants.ALPHA_MODES.PMA;
                    }
                    callback(resource.texture.baseTexture);
                }
                else {
                    callback(null);
                }
            });
        }
    };
}
/**
 * @public
 */
function syncImageLoaderAdapter(baseUrl, crossOrigin) {
    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {
        baseUrl += '/';
    }
    return function (line, callback) {
        callback(core.BaseTexture.from(line, crossOrigin));
    };
}
/**
 * @public
 */
function staticImageLoader(pages) {
    return function (line, callback) {
        var page = pages[line] || pages['default'];
        if (page && page.baseTexture)
            callback(page.baseTexture);
        else
            callback(page);
    };
}

exports.AbstractSpineParser = AbstractSpineParser;
exports.imageLoaderAdapter = imageLoaderAdapter;
exports.staticImageLoader = staticImageLoader;
exports.syncImageLoaderAdapter = syncImageLoaderAdapter;
//# sourceMappingURL=loader-base.js.map
